# Especialista Java

<p  align="center">
	 <img alt="Proffy" src=".github/especialista-java.png"/>  
</p>

## Conte√∫do program√°tico üìñ

### 1. Plataforma Java e ambiente de desenvolvimento

1.1. Introdu√ß√£o ao curso
1.2. Como aprender Java e pedir ajuda
1.3. Por que aprender Java?
1.4. Um pouco sobre a hist√≥ria do Java
1.5. Conhecendo as plataformas Java
1.6. Conhecendo a M√°quina Virtual Java (JVM)
1.7. JRE e JDK: qual √© a diferen√ßa?
1.8. Conhecendo as vers√µes do Java
1.9. Conhecendo as distribui√ß√µes de JDKs e licen√ßas de uso
1.10. Instalando o JDK no Ubuntu e macOS com SDKMan!
1.11. Instalando o JDK no Windows
1.12. Escolhendo um editor de c√≥digo simples

### 2. Fundamentos da Linguagem Java

2.1. Criando o primeiro programa Java
2.2. Compilando e executando um programa Java
2.3. Desafio: corre√ß√£o de erros
2.4. Escrevendo coment√°rios no c√≥digo
2.5. Conhecendo e usando conven√ß√µes de c√≥digo
2.6. Palavras reservadas5m 9s
2.7. Trabalhando com vari√°veis18m 5s
2.8. Operadores aritm√©ticos9m 59s
2.9. Desafio: vari√°veis e operadores aritm√©ticos
2.10. Abreviando operadores aritm√©ticos
2.11. Operadores de incremento e decremento
2.12. Tipos primitivos: boolean, char, byte e short
2.13. Tipos primitivos: int e long
2.14. Tipos primitivos: float e double
2.15. Convers√£o de tipos primitivos
2.16. Desafio: tipos primitivos e convers√£o
2.17. Promo√ß√£o aritm√©tica
2.18. Desafio: promo√ß√£o aritm√©tica
2.19. Trabalhando com String
2.20. Usando sequ√™ncias de escape
2.21. Formatando a sa√≠da com printf
2.22. Recebendo entrada de dados
2.23. Desafio: String, entrada de dados, printf, etc
2.24. Usando JShell: o REPL do Java

### 3. Estruturas de controle e operadores

3.1. Operadores de igualdade e de nega√ß√£o (un√°rio)
3.2. Operadores de compara√ß√£o
3.3. Operadores l√≥gicos
3.4. Desafio: operadores de igualdade e l√≥gicos
3.5. Curto-circuito de operadores l√≥gicos
3.6. Preced√™ncia de operadores l√≥gicos
3.7. Estrutura condicional if
3.8. Estruturas condicionais else e else if
3.9. Desafio: calculadora complexa de IMC
3.10. Escopos e inicializa√ß√£o de vari√°veis
3.11. Estrutura condicional switch
3.12. Cl√°usula break
3.13. Switch Expressions
3.14. Operador tern√°rio
3.15. Desafio: estrutura switch e operador tern√°rio
3.16. Estrutura de repeti√ß√£o for
3.17. Estrutura de repeti√ß√£o while
3.18. Estrutura de repeti√ß√£o do/while
3.19. Cl√°usulas break e continue
3.20. Desafio: estruturas de repeti√ß√£o

### 4. Produtividade com a IDE IntelliJ IDEA

4.1. Conhecendo as IDEs mais populares
4.2. Instalando e conhecendo a IntelliJ IDEA
4.3. Mais da IntelliJ IDEA: build, run, plugins, terminal e shared index
4.4. Usando Code Completion, Live Templates e Postfix Completion
4.5. Conhecendo os principais atalhos
4.6. Mais atalhos do IntelliJ IDEA
4.7. Usando o Debugger para depurar o seu c√≥digo
4.8. Debugger: silenciamento, condi√ß√£o e desativa√ß√£o de breakpoints
4.9. Debugger: gerenciando vari√°veis e avaliando express√µes
4.10. Debugger: watches e logging
4.11. Rascunhando e testando c√≥digo com Scratch Files
4.12. Testando c√≥digo com JShell Console da IDE
4.13. Consist√™ncia no estilo de codifica√ß√£o com EditorConfig
4.14. Importando um projeto existente na IDE

### 5. Mergulhando em orienta√ß√£o a objetos

5.1. O paradigma da Programa√ß√£o Orientada a Objetos (POO)
5.2. Entendendo o conceito de classes e objetos
5.3. Criando uma classe com atributos
5.4. Instanciando objetos
5.5. Acessando atributos de objetos
5.6. Conhecendo o diagrama de classes da UML
5.7. Desafio: instanciando objetos e acessando os atributos
5.8. Composi√ß√£o de objetos
5.9. Atribuindo o objeto na composi√ß√£o
5.10. Diagrama de classes: associa√ß√£o, agrega√ß√£o e composi√ß√£o
5.11. Valores padr√£o e inicializa√ß√£o de vari√°veis de inst√¢ncia
5.12. Inicializa√ß√£o de objetos em vari√°veis de inst√¢ncia
5.13. Caindo a ficha: vari√°veis referenciam objetos
5.14. Criando e invocando um m√©todo
5.15. Implementando a l√≥gica do m√©todo
5.16. IntelliJ IDEA: debug de chamadas de m√©todos
5.17. M√©todos com retorno
5.18. Implementando m√©todos menores e evitando duplica√ß√£o de c√≥digo
5.19. Saindo do m√©todo com a cl√°usula return
5.20. M√©todos que retornam objetos
5.21. Refatorando para tornar uma classe mais rica
5.22. Discutindo nome e responsabilidade da classe
5.23. M√©todos com argumentos
5.24. Passando objetos como argumentos de m√©todos
5.25. Desafio: composi√ß√£o de objetos e m√©todos
5.26. Diagrama de classes: m√©todos e depend√™ncias
5.27. M√©todos que alteram vari√°vel de inst√¢ncia
5.28. M√©todos que alteram o valor de par√¢metro do tipo primitivo
5.29. M√©todos que alteram o estado de objeto recebido como par√¢metro
5.30. Usando a palavra-chave this
5.31. Atributos de classe com o modificador static
5.32. M√©todo de inst√¢ncia alterando vari√°vel est√°tica
5.33. M√©todos de classe (est√°ticos)
5.34. M√©todo est√°tico acessando membro de inst√¢ncia
5.35. Desafio: membros est√°ticos
5.36. Declarando constantes com static e final
5.37. Modificador final em vari√°veis locais
5.38. Sobrecarga de m√©todos
5.39. Infer√™ncia de tipo de vari√°vel local
5.40. Desafio: modificador final em vari√°veis locais
5.41. Desafio: sobrecarga de m√©todos
5.42. Desafio: infer√™ncia de tipo de vari√°vel local

### 6. Come√ßando com boas pr√°ticas e c√≥digo limpo

6.1. Boas pr√°ticas com Effective Java e Clean Code
6.2. C√≥digo Limpo: escolha bons nomes
6.3. C√≥digo Limpo: tamanho e organiza√ß√£o de classes
6.4. C√≥digo Limpo: coment√°rios no c√≥digo
6.5. C√≥digo Limpo: m√©todos pequenos e que fazem s√≥ uma coisa
6.6. C√≥digo Limpo: pensando melhor nos argumentos de m√©todos
6.7. Boas pr√°ticas: valide os argumentos

### 7. Wrappers e boxing

7.1. Usando classes wrapper
7.2. M√©todos de convers√£o
7.3. Autoboxing e unboxing
7.4. Comparando wrappers
7.5. Desafio: wrappers e boxing
7.6. Boas pr√°ticas: prefira tipos primitivos a wrappers

### 8. Trabalhando com Arrays

8.1. Declarando e inicializando arrays
8.2. Acessando e atribuindo elementos de arrays
8.3. Iterando em arrays
8.4. Transformando arrays em representa√ß√µes em string
8.5. Ordenando arrays em ordem natural e reversa
8.6. Criando arrays de objetos
8.7. Iterando em arrays de objetos
8.8. Copiando e expandindo arrays
8.9. Removendo elementos de arrays
8.10. Desafio: arrays
8.11. Um pouco da ArrayList da Collections API
8.12. Desafio: ArrayList
8.13. Diagrama de classes: multiplicidade para arrays
8.14. Boas pr√°ticas: retorne arrays ou cole√ß√µes vazias no lugar de null
8.15. Criando arrays multidimensionais
8.16. Iterando em arrays multidimensionais
8.17. Lendo os par√¢metros da linha de comando
8.18. Criando m√©todos com argumentos vari√°veis com Varargs
8.19. Boas pr√°ticas: use varargs com cuidado
8.20. Desafio: varargs

### 9. Gerenciamento de mem√≥ria do Java

9.1. Estrutura da mem√≥ria da JVM
9.2. Call Stack, Stack Memory e Heap Memory
9.3. Informa√ß√µes da Mem√≥ria Heap com a Runtime API
9.4. Configurando a Mem√≥ria Heap da JVM
9.5. Garbage Collector
9.6. Inalcan√ßabilidade de objetos
9.7. Quando esgota a Mem√≥ria Heap: OutOfMemoryError
9.8. Boas pr√°ticas: remova refer√™ncias de objetos n√£o usados

### 10. Construtores, pacotes e visibilidade

10.1. Criando e chamando construtores
10.2. Construtores com par√¢metros
10.3. Sobrecarga de construtores
10.4. Boas pr√°ticas: valide os argumentos de construtores tamb√©m
10.5. Encadeamento de chamadas de construtores
10.6. Diagrama de classes: construtores
10.7. Desafio: construtores
10.8. Modificador final em vari√°veis de inst√¢ncia
10.9. Organizando as classes em pacotes
10.10. Importando classes de pacotes
10.11. Modificador de acesso public e default
10.12. Modificador de acesso private
10.13. Diagrama de classes: visibilidade public, package e private
10.14. Desafio: pacotes e modificadores de acesso
10.15. Importando membros est√°ticos (static import)
10.16. M√∫ltiplas classes n√£o-p√∫blicas em um √∫nico arquivo
10.17. Conhecendo a documenta√ß√£o JavaDoc do Java SE

### 11. Encapsulamento, JavaBeans e Records

11.1. O problema da falta de encapsulamento
11.2. Implementando encapsulamento
11.3. JavaBeans e m√©todos getters e setters
11.4. IntelliJ IDEA: gerando getters e setters
11.5. Desafio: encapsulamento e JavaBeans
11.6. Boas pr√°ticas: use m√©todos de acesso em classes p√∫blicas (incluindo Tell Don't Ask)
11.7. C√≥digo limpo: Lei de Demeter (incluindo Train Wreck)
11.8. Boas pr√°ticas: n√£o permita instancia√ß√£o com construtor privado
11.9. Boas pr√°ticas: crie c√≥pias defensivas
11.10. Boas pr√°ticas: minimize a mutabilidade (incluindo Value Object)
11.11. Records
11.12. Diagrama de classes: Records

### 12. Heran√ßa

12.1. Conhecendo o projeto deste m√≥dulo
12.2. Criando classes etiquetadas (tagged classes)
12.3. Duplicando classes e isolando os comportamentos
12.4. Conhecendo heran√ßa e o relacionamento no diagrama de classes
12.5. Implementando heran√ßa
12.6. Sobrescrita de m√©todos
12.7. Modificador de acesso protected
12.8. Anota√ß√£o @Override
12.9. Chamando m√©todo da superclasse com super
12.10. A classe Object
12.11. Invocando construtores da superclasse
12.12. Criando construtores com par√¢metros na superclasse e subclasses
12.13. Boas pr√°ticas: sempre sobrescreva o m√©todo Object.toString
12.14. Modificador final em classes e m√©todos
12.15. Desafio: implementando heran√ßa
12.16. Sobrescrevendo o m√©todo Object.equals
12.17. Boas pr√°ticas: obede√ßa o contrato ao sobrescrever o m√©todo equals

### 13. Polimorfismo e Classes Abstratas

13.1. Upcasting de refer√™ncias
13.2. O problema que polimorfismo resolve
13.3. Entendendo o polimorfismo
13.4. Downcasting de refer√™ncias
13.5. Operador instanceof
13.6. Pattern Matching para o operador instanceof
13.7. Evitando o uso de instanceof
13.8. Criando um projeto de faturamento
13.9. Classes abstratas
13.10. M√©todos abstratos
13.11. Desafio: polimorfismo e classes abstratas

### 14. Interfaces

14.1. Entendendo as interfaces
14.2. Criando a primeira interface
14.3. Implementando a primeira interface
14.4. Nova interface e inje√ß√£o de depend√™ncias
14.5. Conhecendo o projeto da financeira
14.6. Quando heran√ßa de classes se torna um problema
14.7. C√≥digo mais flex√≠vel: refatorando para usar interfaces
14.8. M√©todos default em interfaces
14.9. Classes abstratas com interfaces
14.10. M√©todos privados em interfaces
14.11. M√©todos est√°ticos em interfaces
14.12. Vari√°veis s√£o est√°ticas e finais em interfaces
14.13. Implementando m√∫ltiplas interfaces
14.14. Heran√ßa de interfaces
14.15. Desafio: interfaces
