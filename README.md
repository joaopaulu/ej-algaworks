# Especialista Java

<p  align="center">
	 <img alt="Proffy" src=".github/especialista-java.png"/>  
</p>

## Conte√∫do program√°tico üìñ

### 1. Plataforma Java e ambiente de desenvolvimento

1.1. Introdu√ß√£o ao curso
1.2. Como aprender Java e pedir ajuda
1.3. Por que aprender Java?
1.4. Um pouco sobre a hist√≥ria do Java
1.5. Conhecendo as plataformas Java
1.6. Conhecendo a M√°quina Virtual Java (JVM)
1.7. JRE e JDK: qual √© a diferen√ßa?
1.8. Conhecendo as vers√µes do Java
1.9. Conhecendo as distribui√ß√µes de JDKs e licen√ßas de uso
1.10. Instalando o JDK no Ubuntu e macOS com SDKMan!
1.11. Instalando o JDK no Windows
1.12. Escolhendo um editor de c√≥digo simples

### 2. Fundamentos da Linguagem Java

2.1. Criando o primeiro programa Java
2.2. Compilando e executando um programa Java
2.3. Desafio: corre√ß√£o de erros
2.4. Escrevendo coment√°rios no c√≥digo
2.5. Conhecendo e usando conven√ß√µes de c√≥digo
2.6. Palavras reservadas5m 9s
2.7. Trabalhando com vari√°veis18m 5s
2.8. Operadores aritm√©ticos9m 59s
2.9. Desafio: vari√°veis e operadores aritm√©ticos
2.10. Abreviando operadores aritm√©ticos
2.11. Operadores de incremento e decremento
2.12. Tipos primitivos: boolean, char, byte e short
2.13. Tipos primitivos: int e long
2.14. Tipos primitivos: float e double
2.15. Convers√£o de tipos primitivos
2.16. Desafio: tipos primitivos e convers√£o
2.17. Promo√ß√£o aritm√©tica
2.18. Desafio: promo√ß√£o aritm√©tica
2.19. Trabalhando com String
2.20. Usando sequ√™ncias de escape
2.21. Formatando a sa√≠da com printf
2.22. Recebendo entrada de dados
2.23. Desafio: String, entrada de dados, printf, etc
2.24. Usando JShell: o REPL do Java

### 3. Estruturas de controle e operadores

3.1. Operadores de igualdade e de nega√ß√£o (un√°rio)
3.2. Operadores de compara√ß√£o
3.3. Operadores l√≥gicos
3.4. Desafio: operadores de igualdade e l√≥gicos
3.5. Curto-circuito de operadores l√≥gicos
3.6. Preced√™ncia de operadores l√≥gicos
3.7. Estrutura condicional if
3.8. Estruturas condicionais else e else if
3.9. Desafio: calculadora complexa de IMC
3.10. Escopos e inicializa√ß√£o de vari√°veis
3.11. Estrutura condicional switch
3.12. Cl√°usula break
3.13. Switch Expressions
3.14. Operador tern√°rio
3.15. Desafio: estrutura switch e operador tern√°rio
3.16. Estrutura de repeti√ß√£o for
3.17. Estrutura de repeti√ß√£o while
3.18. Estrutura de repeti√ß√£o do/while
3.19. Cl√°usulas break e continue
3.20. Desafio: estruturas de repeti√ß√£o

### 4. Produtividade com a IDE IntelliJ IDEA

4.1. Conhecendo as IDEs mais populares
4.2. Instalando e conhecendo a IntelliJ IDEA
4.3. Mais da IntelliJ IDEA: build, run, plugins, terminal e shared index
4.4. Usando Code Completion, Live Templates e Postfix Completion
4.5. Conhecendo os principais atalhos
4.6. Mais atalhos do IntelliJ IDEA
4.7. Usando o Debugger para depurar o seu c√≥digo
4.8. Debugger: silenciamento, condi√ß√£o e desativa√ß√£o de breakpoints
4.9. Debugger: gerenciando vari√°veis e avaliando express√µes
4.10. Debugger: watches e logging
4.11. Rascunhando e testando c√≥digo com Scratch Files
4.12. Testando c√≥digo com JShell Console da IDE
4.13. Consist√™ncia no estilo de codifica√ß√£o com EditorConfig
4.14. Importando um projeto existente na IDE

### 5. Mergulhando em orienta√ß√£o a objetos

5.1. O paradigma da Programa√ß√£o Orientada a Objetos (POO)
5.2. Entendendo o conceito de classes e objetos
5.3. Criando uma classe com atributos
5.4. Instanciando objetos
5.5. Acessando atributos de objetos
5.6. Conhecendo o diagrama de classes da UML
5.7. Desafio: instanciando objetos e acessando os atributos
5.8. Composi√ß√£o de objetos
5.9. Atribuindo o objeto na composi√ß√£o
5.10. Diagrama de classes: associa√ß√£o, agrega√ß√£o e composi√ß√£o
5.11. Valores padr√£o e inicializa√ß√£o de vari√°veis de inst√¢ncia
5.12. Inicializa√ß√£o de objetos em vari√°veis de inst√¢ncia
5.13. Caindo a ficha: vari√°veis referenciam objetos
5.14. Criando e invocando um m√©todo
5.15. Implementando a l√≥gica do m√©todo
5.16. IntelliJ IDEA: debug de chamadas de m√©todos
5.17. M√©todos com retorno
5.18. Implementando m√©todos menores e evitando duplica√ß√£o de c√≥digo
5.19. Saindo do m√©todo com a cl√°usula return
5.20. M√©todos que retornam objetos
5.21. Refatorando para tornar uma classe mais rica
5.22. Discutindo nome e responsabilidade da classe
5.23. M√©todos com argumentos
5.24. Passando objetos como argumentos de m√©todos
5.25. Desafio: composi√ß√£o de objetos e m√©todos
5.26. Diagrama de classes: m√©todos e depend√™ncias
5.27. M√©todos que alteram vari√°vel de inst√¢ncia
5.28. M√©todos que alteram o valor de par√¢metro do tipo primitivo
5.29. M√©todos que alteram o estado de objeto recebido como par√¢metro
5.30. Usando a palavra-chave this
5.31. Atributos de classe com o modificador static
5.32. M√©todo de inst√¢ncia alterando vari√°vel est√°tica
5.33. M√©todos de classe (est√°ticos)
5.34. M√©todo est√°tico acessando membro de inst√¢ncia
5.35. Desafio: membros est√°ticos
5.36. Declarando constantes com static e final
5.37. Modificador final em vari√°veis locais
5.38. Sobrecarga de m√©todos
5.39. Infer√™ncia de tipo de vari√°vel local
5.40. Desafio: modificador final em vari√°veis locais
5.41. Desafio: sobrecarga de m√©todos
5.42. Desafio: infer√™ncia de tipo de vari√°vel local

### 6. Come√ßando com boas pr√°ticas e c√≥digo limpo

6.1. Boas pr√°ticas com Effective Java e Clean Code
6.2. C√≥digo Limpo: escolha bons nomes
6.3. C√≥digo Limpo: tamanho e organiza√ß√£o de classes
6.4. C√≥digo Limpo: coment√°rios no c√≥digo
6.5. C√≥digo Limpo: m√©todos pequenos e que fazem s√≥ uma coisa
6.6. C√≥digo Limpo: pensando melhor nos argumentos de m√©todos
6.7. Boas pr√°ticas: valide os argumentos

### 7. Wrappers e boxing

7.1. Usando classes wrapper
7.2. M√©todos de convers√£o
7.3. Autoboxing e unboxing
7.4. Comparando wrappers
7.5. Desafio: wrappers e boxing
7.6. Boas pr√°ticas: prefira tipos primitivos a wrappers

### 8. Trabalhando com Arrays

8.1. Declarando e inicializando arrays
8.2. Acessando e atribuindo elementos de arrays
8.3. Iterando em arrays
8.4. Transformando arrays em representa√ß√µes em string
8.5. Ordenando arrays em ordem natural e reversa
8.6. Criando arrays de objetos
8.7. Iterando em arrays de objetos
8.8. Copiando e expandindo arrays
8.9. Removendo elementos de arrays
8.10. Desafio: arrays
8.11. Um pouco da ArrayList da Collections API
8.12. Desafio: ArrayList
8.13. Diagrama de classes: multiplicidade para arrays
8.14. Boas pr√°ticas: retorne arrays ou cole√ß√µes vazias no lugar de null
8.15. Criando arrays multidimensionais
8.16. Iterando em arrays multidimensionais
8.17. Lendo os par√¢metros da linha de comando
8.18. Criando m√©todos com argumentos vari√°veis com Varargs
8.19. Boas pr√°ticas: use varargs com cuidado
8.20. Desafio: varargs

### 9. Gerenciamento de mem√≥ria do Java

9.1. Estrutura da mem√≥ria da JVM
9.2. Call Stack, Stack Memory e Heap Memory
9.3. Informa√ß√µes da Mem√≥ria Heap com a Runtime API
9.4. Configurando a Mem√≥ria Heap da JVM
9.5. Garbage Collector
9.6. Inalcan√ßabilidade de objetos
9.7. Quando esgota a Mem√≥ria Heap: OutOfMemoryError
9.8. Boas pr√°ticas: remova refer√™ncias de objetos n√£o usados

### 10. Construtores, pacotes e visibilidade

10.1. Criando e chamando construtores
10.2. Construtores com par√¢metros
10.3. Sobrecarga de construtores
10.4. Boas pr√°ticas: valide os argumentos de construtores tamb√©m
10.5. Encadeamento de chamadas de construtores
10.6. Diagrama de classes: construtores
10.7. Desafio: construtores
10.8. Modificador final em vari√°veis de inst√¢ncia
10.9. Organizando as classes em pacotes
10.10. Importando classes de pacotes
10.11. Modificador de acesso public e default
10.12. Modificador de acesso private
10.13. Diagrama de classes: visibilidade public, package e private
10.14. Desafio: pacotes e modificadores de acesso
10.15. Importando membros est√°ticos (static import)
10.16. M√∫ltiplas classes n√£o-p√∫blicas em um √∫nico arquivo
10.17. Conhecendo a documenta√ß√£o JavaDoc do Java SE

### 11. Encapsulamento, JavaBeans e Records

11.1. O problema da falta de encapsulamento
11.2. Implementando encapsulamento
11.3. JavaBeans e m√©todos getters e setters
11.4. IntelliJ IDEA: gerando getters e setters
11.5. Desafio: encapsulamento e JavaBeans
11.6. Boas pr√°ticas: use m√©todos de acesso em classes p√∫blicas (incluindo Tell Don't Ask)
11.7. C√≥digo limpo: Lei de Demeter (incluindo Train Wreck)
11.8. Boas pr√°ticas: n√£o permita instancia√ß√£o com construtor privado
11.9. Boas pr√°ticas: crie c√≥pias defensivas
11.10. Boas pr√°ticas: minimize a mutabilidade (incluindo Value Object)
11.11. Records
11.12. Diagrama de classes: Records

### 12. Heran√ßa

12.1. Conhecendo o projeto deste m√≥dulo
12.2. Criando classes etiquetadas (tagged classes)
12.3. Duplicando classes e isolando os comportamentos
12.4. Conhecendo heran√ßa e o relacionamento no diagrama de classes
12.5. Implementando heran√ßa
12.6. Sobrescrita de m√©todos
12.7. Modificador de acesso protected
12.8. Anota√ß√£o @Override
12.9. Chamando m√©todo da superclasse com super
12.10. A classe Object
12.11. Invocando construtores da superclasse
12.12. Criando construtores com par√¢metros na superclasse e subclasses
12.13. Boas pr√°ticas: sempre sobrescreva o m√©todo Object.toString
12.14. Modificador final em classes e m√©todos
12.15. Desafio: implementando heran√ßa
12.16. Sobrescrevendo o m√©todo Object.equals
12.17. Boas pr√°ticas: obede√ßa o contrato ao sobrescrever o m√©todo equals

### 13. Polimorfismo e Classes Abstratas

13.1. Upcasting de refer√™ncias
13.2. O problema que polimorfismo resolve
13.3. Entendendo o polimorfismo
13.4. Downcasting de refer√™ncias
13.5. Operador instanceof
13.6. Pattern Matching para o operador instanceof
13.7. Evitando o uso de instanceof
13.8. Criando um projeto de faturamento
13.9. Classes abstratas
13.10. M√©todos abstratos
13.11. Desafio: polimorfismo e classes abstratas

### 14. Interfaces

14.1. Entendendo as interfaces
14.2. Criando a primeira interface
14.3. Implementando a primeira interface
14.4. Nova interface e inje√ß√£o de depend√™ncias
14.5. Conhecendo o projeto da financeira
14.6. Quando heran√ßa de classes se torna um problema
14.7. C√≥digo mais flex√≠vel: refatorando para usar interfaces
14.8. M√©todos default em interfaces
14.9. Classes abstratas com interfaces
14.10. M√©todos privados em interfaces
14.11. M√©todos est√°ticos em interfaces
14.12. Vari√°veis s√£o est√°ticas e finais em interfaces
14.13. Implementando m√∫ltiplas interfaces
14.14. Heran√ßa de interfaces
14.15. Desafio: interfaces

### 15. Boas pr√°ticas de Heran√ßa e Interface

15.1. Rigidez do c√≥digo com heran√ßa
15.2. Boas pr√°ticas: prefira composi√ß√£o em vez de heran√ßa de classes
15.3. C√≥digo fr√°gil: alto acoplamento com heran√ßa
15.4. Boas pr√°ticas: reduzindo acoplamento com composi√ß√£o
15.5. Decorator Pattern: consolidando os conhecimentos
15.6. Boas pr√°ticas: projete interfaces com cuidado
15.7. Boas pr√°ticas: use interfaces apenas para definir tipos
15.8. Boas pr√°ticas: referencie objetos por suas interfaces

### 16. Exce√ß√µes

16.1 Introdu√ß√£o √†s exce√ß√µes
16.2 Lan√ßando exce√ß√µes
16.3 Stack Trace: interpretando e analisando exce√ß√µes
16.4 Capturando exce√ß√µes com try/catch
16.5 Relan√ßando exce√ß√µes e printStackTrace
16.6 Capturando exce√ß√µes com m√∫ltiplos blocos catch
16.7 Hierarquia das exce√ß√µes, checked e unchecked exceptions
16.8 Capturando checked exceptions
16.9 Criando exce√ß√µes customizadas
16.10 Vari√°veis de inst√¢ncia em exce√ß√µes customizadas
16.11. Lan√ßando e propagando checked exceptions
16.12. Capturando exce√ß√µes menos espec√≠ficas (upcasting)
16.13. Capturando e lan√ßando nova exce√ß√£o
16.14. Boa pr√°tica: embrulhe a causa raiz
16.15. Capturando exce√ß√µes com multi-catch
16.16. Usando a cl√°usula finally
16.17. IntelliJ IDEA: lan√ßando exce√ß√µes na ferramenta de debug
16.18. IntelliJ IDEA: adicionando Java Exception Breakpoints
16.19. Boas pr√°ticas: lance exce√ß√µes ao inv√©s de retornar null
16.20. Boas pr√°ticas: n√£o engula exce√ß√µes
16.21. Desafio: exce√ß√µes

### 17. Generics

17.1. Introdu√ß√£o aos Generics
17.2. Implementando m√©todos gen√©ricos
17.3. Delimitando tipos gen√©ricos
17.4. Criando classes gen√©ricas
17.5. Criando interfaces gen√©ricas
17.6. Usando curingas para tipos desconhecidos
17.7. Desafio: Generics

### 18. Collections Framework

18.1. Por que mais uma API?
18.2. Introdu√ß√£o √†s listas e ao tipo List
18.3. Como funciona a ArrayList
18.4. Usando listas do tipo ArrayList
18.5. Iterando em lista com for tradicional
18.6. Usando listas com Generics
18.7. Localizando objetos em listas
18.8. Manipulando objetos da lista
18.9. Percorrendo a lista com Iterator
18.10. Percorrendo a lista com ListIterator
18.11. Percorrendo Iterables com enhanced for
18.12. LinkedList: mais performance na adi√ß√£o e remo√ß√£o
18.13. Usando listas do tipo LinkedList
18.14. Vector: a lista thread-safe
18.15. Boas pr√°ticas: reduza o acoplamento usando o tipo da interface
18.16. Convertendo de lista para array
18.17. Ordenando listas pela ordem natural
18.18. Boas pr√°ticas: considere implementar a interface Comparable
18.19. Comparators: ordenando listas com outros crit√©rios
18.20. Desafio: listas
18.21. Introdu√ß√£o aos conjuntos e ao tipo Set
18.22. Usando conjuntos do tipo HashSet
18.23. Tabelas de espalhamento (hash tables)
18.24. Implementando o m√©todo hashCode
18.25. Testando a implementa√ß√£o de hashCode com HashSet
18.26. Usando conjuntos do tipo TreeSet
18.27. Usando conjuntos do tipo LinkedHashSet
18.28. Desafio: conjuntos
18.29. Introdu√ß√£o aos mapas e ao tipo Map
18.30. Usando mapas dos tipos HashMap e Hashtable
18.31. LinkedHashTable e TreeMap: outras implementa√ß√µes de mapas
18.32. Desafio: mapas
18.33. Boas pr√°ticas: encapsulamento com cole√ß√µes n√£o-modific√°veis
18.34. Cole√ß√µes imut√°veis
18.35. Usando a API de List para manipular arrays

### 19. Enumera√ß√µes

19.1. Usando enumera√ß√µes √† moda antiga
19.2. Criando tipos Enum
19.3. Diagrama de classes: enumera√ß√£o
19.4. Usando os m√©todos do tipo Enum
19.5. Declarando e inicializando propriedades e construtores
19.6. Implementando m√©todos
19.7. Implementando m√©todos abstratos
19.8. Boas pr√°ticas: substitua par√¢metros booleanos por enums
19.9. Desafio: enumera√ß√µes

### 20. Trabalhando com Strings

20.1. Compara√ß√£o de strings
20.2. Pool de strings
20.3. Validando o conte√∫do de strings
20.4. Extraindo trechos da String com indexOf e substring
20.5. Extraindo trechos da String com lastIndexOf e substring
20.6. Transformando strings
20.7. Implementando algoritmos usando os m√©todos da classe String
20.8. Desafio: valida√ß√£o de e-mail
20.9. Testando correspond√™ncias de strings com express√µes regulares
20.10. Web Scraping: buscando correspond√™ncias com Pattern e Matcher
20.11. Manipulando strings com express√µes regulares
20.12. Boas pr√°ticas: use StringBuilder para mais performance
20.13. C√≥digo mais limpo com Text blocks
20.14. Desafio: Text blocks e express√µes regulares

### 21. Trabalhando com N√∫meros

21.1. Comparando n√∫meros da forma correta
21.2. Caching de classes wrapper
21.3. Opera√ß√µes matem√°ticas com java.lang.Math
21.4. Boas pr√°ticas: evite float e double se precis√£o √© importante
21.5. Precis√£o nos c√°lculos com BigDecimal
21.6. Divis√£o de BigDecimal e formas de arredondamento
21.7. Formata√ß√£o decimal com DecimalFormat
21.8. Localizando a formata√ß√£o de n√∫meros com Locale
21.9. Formata√ß√£o num√©rica compacta
21.10. Transformando String em n√∫meros com DecimalFormat
21.11. Desafio: formata√ß√£o num√©rica

### 22. Date e Calendar: as APIs legadas

22.1. Entendendo os fusos hor√°rios
22.2. Instanciando datas com o tipo Date
22.3. Calculando e comparando datas com Date
22.4. Formatando Date para String
22.5. Convertendo de String para Date
22.6. Conhecendo o tipo Calendar
22.7. Obtendo unidades de tempo e atribuindo uma Date em Calendar
22.8. Opera√ß√µes de datas com o tipo Calendar
22.9. Comparando datas com o tipo Calendar
22.10. Desafio: calculando datas com Calendar

### 23. Date/Time API: mais nova e moderna

23.1. Introdu√ß√£o √† Date and Time API e ao padr√£o ISO-8601
23.2. Instant: representando um momento na linha do tempo
23.3. LocalDate: representando apenas a data
23.4. LocalTime: representando apenas o hor√°rio
23.5. LocalDateTime: representando data e hora
23.6. Outras formas de obter inst√¢ncias de LocalDate, LocalTime e LocalDateTime
23.7. Formatando data/hora da nova API
23.8. Convertendo de String para objetos temporais
23.9. Desafio: LocalDate, LocalTime e LocalDateTime
23.10. Obtendo campos de objetos temporais e a enum ChronoField
23.11. Alterando campos de objetos temporais com m√©todos with
23.12. Adicionando e subtraindo objetos temporais com m√©todos de conveni√™ncia
23.13. Calculando objetos temporais com ChronoUnit
23.14. Desafio: calculadora de parcelas
23.15. Representando per√≠odos com a classe Period
23.16. Calculando per√≠odos de objetos temporais
23.17. Representando dura√ß√µes com a classe Duration
23.18. Calculando dura√ß√µes de objetos temporais
23.19. Desafio: calculando per√≠odo
23.20. DayOfWeek: representando o dia da semana
23.21. Year: representando o ano
23.22. Month: representando o m√™s
23.23. MonthDay: representando o dia do m√™s
23.24. YearMonth: representando o m√™s do ano
23.25. Alterando campos de objetos temporais com TemporalAdjusters
23.26. Comparando objetos temporais
23.27. Desafio: TemporalAdjuster
23.28. Identificando fusos com ZoneId e ZoneOffset
23.29. Instanciando objetos temporais em um fuso hor√°rio espec√≠fico
23.30. ZonedDateTime: data/hora com fuso hor√°rio
23.31. Calculando e convertendo de/para ZonedDateTime
23.32. OffsetDateTime e OffsetTime: data e hora com deslocamento do UTC
23.33. Desafio: trabalhando com fuso hor√°rio

### 24. Classes aninhadas

24.1. Introdu√ß√£o √†s classes aninhadas
24.2. Classes aninhadas est√°ticas
24.3. Modificadores de acesso de classes aninhadas
24.4. Enum como membro est√°tico de uma classe
24.5. Classes aninhadas n√£o-est√°ticas
24.6. Shadowing em classes aninhadas
24.7. Classes locais
24.8. Classes an√¥nimas
24.9. Desafio: classes aninhadas

### 25. Express√µes Lambda e Method Reference

25.1. Introdu√ß√£o ao m√≥dulo
25.2. Implementando Express√µes Lambda
25.3. Entendendo as interfaces funcionais
25.4. Usando a interface @FunctionalInterface
25.5. Boas pr√°ticas: prefira lambdas a classes an√¥nimas
25.6. Boas pr√°ticas: torne as lambdas mais concisas
25.7. Implementando Comparator com lambda
25.8. Boas pr√°ticas: prefira interfaces funcionais padr√£o
25.9. As 4 principais interfaces funcionais
25.10. Interface funcional Predicate: removendo elementos de cole√ß√µes
25.11. Interface funcional Consumer: iterando em cole√ß√µes com forEach
25.12. Interface funcional Function: ordenando lista com Comparator.comparing
25.13. Usando Method References
25.14. Referenciando m√©todos de uma inst√¢ncia particular
25.15. Referenciando m√©todos est√°ticos
25.16. Referenciando construtores
25.17. Desafio: express√µes lambda e method reference

### 26. Optional

26.1. O jeito tradicional de evitar NPE
26.2. Evoluindo seu c√≥digo com Optional
26.3. Testando valor do Optional com isPresent
26.4. Obtendo valor e lan√ßando exce√ß√£o com orElseThrow
26.5. Obtendo valor alternativo com orElse e orElseGet
26.6. Obtendo e testando valor com ifPresent e ifPresentOrElse
26.7. Testando e filtrando valor com Predicate
26.8. Aplicando transforma√ß√µes com map
26.9. Aplicando transforma√ß√µes com flatMap
26.10. Tipos especiais de Optional para tipos primitivos
26.11. Boas pr√°ticas ao usar Optional
26.12. Desafio: Optional

### 27. Streams API

27.1. Introdu√ß√£o √† Streams API e opera√ß√µes b√°sicas
27.2. Opera√ß√£o intermedi√°ria: Stream.filter
27.3. Opera√ß√£o terminal: Stream.forEach
27.4. Criando o pipeline com encadeamento de opera√ß√µes
27.5. Executando a√ß√µes intermedi√°rias com o m√©todo Stream.peek
27.6. Opera√ß√µes terminais de curto-circuito: findFirst e findAny
27.7. Testando predicados com Stream.anyMatch, Stream.allMatch e Stream.noneMatch
27.8. Ordenando elementos de Streams
27.9. Entendendo o que √© uma opera√ß√£o intermedi√°ria com estado (stateful)
27.10. Aplicando transforma√ß√µes com Stream.map
27.11. Obtendo um Stream de elementos distintos
27.12. Achatando um Stream com Stream.flatMap
27.13. Usando as especializa√ß√µes de Stream para tipos primitivos
27.14. Entendendo as opera√ß√µes de redu√ß√£o com Stream.reduce
27.15. Reduzindo em BigDecimal e usando a fun√ß√£o de combina√ß√£o
27.16. Opera√ß√µes de redu√ß√£o que retornam Optional
27.17. Opera√ß√µes de redu√ß√£o especiais: sum, average e count
27.18. Opera√ß√µes de redu√ß√£o especiais: min e max
27.19. Coletando elementos do Stream em lista com Stream.collect
27.20. Usando coletores padr√£o da classe Collectors
27.21. Usando coletores de listas n√£o-modific√°veis
27.22. Coletando elementos do Stream em mapas
27.23. Gerando mapas agrupados com Collectors.groupingBy
27.24. Gerando mapas agrupados com valores agregados
27.25. Gerando mapas particionados com Collectors.partitioningBy
27.26. Outras formas de obter inst√¢ncias de Stream
27.27. M√©todos Objects.isNull e Objects.nonNull
27.28. Boas pr√°ticas: prefira fun√ß√µes em streams sem efeito colateral
27.29. Desafio: Streams